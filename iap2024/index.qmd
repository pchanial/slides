---
title: "FURAX: a modular JAX toolbox for solving inverse problems in science "

author:
  - "Pierre Chanial, Wassim Kabalan, Simon Biquart"

format:
  revealjs:
    theme: [default, css/custom.scss]
    incremental: false   
    transition: slide
    background-transition: slide
    presentation-size: max-scale
    highlight-style: github
    slide-number: true
    template-partials:
      - css/title-slide.html
output: revealjs

title-slide-attributes:
  data-background-image: "assets/Wallpaper-datacenter-tetris.png"
  data-background-size: fill
  data-background-opacity: "0.2"


logo1 : '
<div style="display: flex; justify-content: space-around; align-items: center; layout-valign="middle">
  <img src="assets/Logos/Furax_logo_transparent.png" style="width: 25%;"/>
  <img src="assets/Logos/JaxLogo.png" style="width: 15%;"/>
  <img src="assets/Logos/Python.png" style="width: 20%;"/>
</div>
<div style="display: flex; justify-content: space-around; align-items: center; layout-valign="middle">
  <img src="assets/Logos/APC.png" style="width: 15%;"/>
  <img src="assets/Logos/scipol.png" style="width: 15%;"/>
  <img src="assets/Logos/ERC.svg" style="width: 15%;"/>
  <img src="assets/Logos/CNRS.svg" style="width: 15%;"/>
</div>
'
---

## FURAX Library

:::{.solutionbox}

::::{.solutionbox-body style="font-size: 22px; border-radius: 10px; border: 2px solid #521463;"}

- <span style="color:#521463; font-size: 28px;">**Motivations and Goals**</span>: Why FURAX ?
<br />
<br />
- <span style="color:#521463; font-size: 28px;">**FURAX Operators**</span>: Presentation of the FURAX building blocks: the Operators.
<br />
<br />
- <span style="color:#521463; font-size: 28px;">**Optimizations**</span>: High-level algebraic reductions with FURAX.
<br />
<br />
- <span style="color:#521463; font-size: 28px;">**CMB Applications**</span>: From map-making to component separation.
::::

:::



# Motivations and Goals {style="font-size: 35px; align=center;"}


# FURAX Building Blocks {style="font-size: 35px; align=center;"}

## FURAX Operators

<br>

The base class `AbstractLinearOperator` provides a default implementation for the usual linear algebra operations.

<br>

::: {style="font-size: 18px;"}

| Operation   | FURAX | Comment |
|-------------|-------|---------|
| Addition    | `A + B` |   |
| Composition | `A @ B` |   |
| Multiplication by scalar | `k * A` | Returns the composition of a HomothetyOperator and A|
| Transpose   | `A.T`  |  Through JAX autodiff, but can be overriden |
| Inverse     | `A.I` | By default, use CG but it can be overriden or configured using a context manager |
| Block Assembly | `BlockColumnOperator([A, B])` `BlockDiagonalOperator([A, B])` `BlockRowOperator([A, B])` | Handle any PyTree of Operators: `Block*Operator({'a': A, 'b': B})`|
| Flattened dense matrix | `A.as_matrix()` | |
| Algebraic reduction | `A.reduce()` | |

: {tbl-colwidths="[25,35,40]"}

:::

## FURAX Operators {style="font-size: 18px;"}

<br/>
<br/>

::: {.columns}

::: {.column width="60%"}

::: {.solutionbox}

:::{.solutionbox-body style="font-size: 17px;"}

| Generic Operator                | Description |
|---------------------------------|-------------|
| `IdentityOperator`              |             |
| `HomothetyOperator`             |             |
| `DiagonalOperator`              |             |
| `BroadcastDiagonalOperator`     | Non-square operator for broadcasting |
| `TensorOperator`    | For dense matrix operations |
| `IndexOperator`                 | Used for projecting skies onto time-ordered series|
| `MoveAxisOperator`              |             |
| `ReshapeOperator`               |             |
| `RavelOperator`                 |             |
| `SymmetricBandToeplitzOperator` | Methods: direct, FFT, overlap and save |
| `Block*Operator` | Block assembly operators (column, diagonal, row)|

:::

:::


:::

::: {.column width="40%"}

::: {.solutionbox}

:::{.solutionbox-body style="font-size: 17px;"}


| Applied Operator          | Description |
|---------------------------|-------------|
| `QURotationOperator`      |             |
| `HWPOperator`             | Ideal HWP   |
| `LinearPolarizerOperator` | Ideal linear polarizer |
| `CMBOperator`             | Parametrized CMB SED |
| `DustOperator`            | Parametrized dust SED |
| `SynchrotronOperator`     | Parametrized synchrotron SED |

:::

:::

:::



:::

# Multi-level Optimizations {style="font-size: 35px;"}

## JAX GPU Compilation Chain

<br/>
<br/>
<br/>
<br/>
<br/>

![From the Python code to the GPU-native code](assets/jax-compilation-chain.png){.nostrech fig-align="center" width="100%"}

## XLA simplifications

:::: {.columns}

::: {.column width="50%"}


#### **Mathematical identities**
- $a\times 0 = a - a = 0$
- $a - 0 = a\times 1 = a / 1 = a^1 = a$
- $a^{-1} = 1/a$, $a^{1/2} = \sqrt{a}$
- $-(-x) = x$
- $(-a)(-b) = ab$
- $ac + bc = (a+b)c$
- $a / const = a \times (1 / const)$
- $(a + c1) + (b + c2) =  a + b + (c1 + c2)$
- $(a / b) / (c / d) = ad / bc$
- $\ln e^x = x$
- $\exp a \exp b = \exp(a+b)$
- $a / \exp b = a \exp(-b)$

:::

::: {.column width="50%"}

#### **Array manipulations**

  - slicing
  - reshaping
  - broadcasting
  - transposition
  - bitcast
  - copies

#### **Ol' Digger's tricks**

  - $a^2 = a \times a$, $a^3 = a \times a \times a$
  - $a / b = a$>>$\log_2 b$ if b is a power of 2
  - $a \mod b = a \& (b - 1)$ if b is a power of 2

:::

and many more (see xla/hlo/transforms/simplifiers/algebraic_simplifier.cc)

:::

::::

## XLA Common Subexpression Elimination (CSE)

:::: {.columns}

::: {.column width="50%"}

```python
import jax
import jax.numpy as jnp

@jax.jit
def func_cse(theta):
    a = jnp.sin(theta)
    b = jnp.sin(theta) + 1
    return a + b
 ```
:::

::: {.column width="50%"}

::: {.fragment fragment-index=1}

![Compiled StableHLO representation](assets/hlo/hlo-func-cse.png){fig-align="center" width="60%"}

:::

:::

::::

## Dead Code Elimination (DCE)

:::: {.columns}

::: {.column width="50%"}

```python
import jax
import jax.numpy as jnp

@jax.jit
def func(x):
    unused = jnp.sin(x)
    y = jnp.exp(x)
    return y[0]
```

::: {.fragment fragment-index=2}

![Full computation vs DCE](assets/hlo/bench-dce.png){fig-align="center" width="190%"}

:::

:::

::: {.column width="50%"}

::: {.fragment fragment-index=1}

![Compiled StableHLO representation](assets/hlo/hlo-func-dce.png){fig-align="center" width="60%"}

:::

:::

::::

## JAX GPU Compilation Chain with FURAX

![From the Python code to the GPU-native code](assets/jax-compilation-chain-with-furax.png){fig-align="center" width="120%"}


## FURAX Algebraic Reductions: Pointing Matrix

::: {style="font-size: 20px;"}

When the time-time noise covariance matrix $N$ is diagonal and $P$ is a "one-to-one" intensity projection matrix:

$$
P = 
\begin{bmatrix}
0 & \cdots & 0 & 1 & 0 & \cdots & 0 \\
0 & 1 & 0 & \cdots & 0 & 0 & \cdots & 0 \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
1 & 0 & \cdots & 0 & 0 & \cdots & 0 \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
0 & 0 & \cdots & 0 & 1 & 0 & \cdots & 0 \\
\end{bmatrix},
$$
the product $P^{\textrm{T}} N^{-1} P$ is diagonal and can therefore be easily inverted (for pixel-pixel covariance matrix or preconditioning). Each term is related to the number of times a pixel of the map has been observed.

For IQU maps, the product is block diagonal, with 3x3 blocks that can also be easily inverted.

By adding a **rule** for this operation, we've seen an performance improvement by more than a **factor of 10** in the forward application (WIP, currently only for $N$ scalar).

:::

## FURAX Algebraic Reductions: Composition of Rotation Matrices


```python
import jax
import jax.numpy as jnp

def rot(x, y, theta):
    rotated_x = x * jnp.cos(theta) - y * jnp.sin(theta)
    rotated_y = x * jnp.sin(theta) + y * jnp.cos(theta)
    return rotated_x, rotated_y

@jax.jit
def func(x, y, theta1, theta2):
    x, y = rot(x, y, theta=theta1)
    return rot(x, y, theta=theta2)
  ```

::: {.fragment fragment-index=1}

![Compiled StableHLO representation](assets/hlo/hlo-rot.png){fig-align="center" width="60%"}

:::

## FURAX Algebraic Reductions: Composition of Rotation Matrices


```python
import jax
import jax.numpy as jnp

def rot(x, y, theta):
    rotated_x = x * jnp.cos(theta) - y * jnp.sin(theta)
    rotated_y = x * jnp.sin(theta) + y * jnp.cos(theta)
    return rotated_x, rotated_y

@jax.jit
def func(x, y, theta1, theta2):
    return rot(x, y, theta=theta1 + theta2)
  ```

::: {.fragment fragment-index=1}

![Compiled StableHLO representation](assets/hlo/hlo-rot-furax.png){fig-align="center" width="60%"}

:::

## FURAX Algebraic Reductions: Block Assembly

::: {style="font-size: 15px;"}

<br>
<br>

| Operation | Reduction |
|---------------------------------|-------------|
| `BlockDiagonalOperator([D1, D2]) @ BlockColumnOperator([C1, C2])`              | `BlockColumnOperator([D1 @ C1, D2 @ C2])`|
| `BlockRowOperator([R1, R2]) @ BlockDiagonalOperator([D1, D2])`              | `BlockRowOperator([R1 @ D1, R2 @ D2])`|
| `BlockRowOperator([R1, R2]) @ BlockColumnOperator([C1, C2])`              | `R1 @ C1 + R2 @ C2`|

: {tbl-colwidths="[60,40]"}

:::

<br>
<br>

#### Practical usage: combining observations

Given two observations
$$
P =
\begin{bmatrix}
P_1 \\
P_2
\end{bmatrix}, \quad
N^{-1} =
\begin{bmatrix}
N_1^{-1} & 0 \\
0 & N_2^{-1}
\end{bmatrix},
$$

The combining results in
$$
P^T N^{-1} P = P_1^T N_1^{-1} P_1 + P_2^T N_2^{-1} P_2.
$$


## FURAX Algebraic Reductions: Instrument Acquisition

Given this modeling of the acquisition, using an ideal linear polarizer and an ideal half wave plate:
$$
H = C_{\textrm{LP}} \, R_{2\theta} \, R_{-2\phi} \, C_{\textrm{HWP}} \, R_{2\phi} \, R_{2\psi} \, P
$$
with

- $\theta$: detector angle
- $\phi$: HWP rotation angle
- $\psi$: telescope rotation angle

FURAX reduces this expression to:

$$
H = C_{\textrm{LP}} \, R_{-2\theta + 4\phi + 2\psi}\, P
$$

# CMB Applications {style="font-size: 35px; align=center;"}

---

## Component Seperation {style="font-size: 22px;"}

::: {.columns}

::: {.column width="50%"}

![](assets/CMB/CMB-Planck.png){.nostretch fig-align="center" width="35%"}

::: {.fragment fragment-index=1}

![](assets/CMB/Plus_symbol.svg){.nostretch fig-align="center" width="10%"}

![](assets/CMB/dust_planck.png){.nostretch fig-align="center" width="35%"}

:::

::: {.fragment fragment-index=2}

![](assets/CMB/Plus_symbol.svg){.nostretch fig-align="center" width="10%"}

![](assets/CMB/synch-planck.png){.nostretch fig-align="center" width="35%"}

:::

:::

::: {.column width="50%"}

- The **Cosmic Microwave Background (CMB)** signal is obscured by various **foregrounds**, making it challenging to detect the true cosmological information.

::: {.fragment fragment-index=1}
- **Dust**: Emission from galactic dust adds significant noise to the CMB, particularly affecting polarization measurements.
:::

::: {.fragment fragment-index=2}
- **Synchrotron Radiation**: Electrons spiraling in the galaxy's magnetic fields produce synchrotron radiation, another major contaminant.
:::

::: {.fragment fragment-index=3}

:::{.solutionbox}

:::{.solutionbox-header style="font-size: 22px;"}

**Component seperation methods**

:::

::::{.solutionbox-body style="font-size: 2Opx;"}

- **Blind Methods**: Like **SMICA** (Spectral Matching Independent Component Analysis)
- **Parametric Methods**: Like **FGbuster** (Foreground Buster)

::::

:::

:::

:::

:::

::: {.notes}

Le signal du fond diffus cosmologique, ou CMB, est en réalité obscurci par plusieurs avant-plans, ce qui rend difficile l'extraction des informations cosmologiques réelles.

L'un des contaminants principaux est la poussière galactique. Cette poussière émet du rayonnement qui ajoute un bruit significatif au CMB, affectant particulièrement les mesures de polarisation.

**NEXT**

Un autre contaminant majeur est la radiation synchrotron. Elle est produite par des électrons en spirale dans les champs magnétiques de notre galaxie, ce qui vient encore plus brouiller le signal cosmologique que l'on souhaite observer.

**AFTER**

Pour pouvoir extraire une valeur fiable du rapport $r$, il est crucial de séparer ou de "démixer" ces composants. Le signal du CMB est mêlé à diverses émissions parasites.

 Il existe différentes méthodes pour cela, principalement des méthodes aveugles comme SMICA, qui fonctionnent sans connaissances préalables des avant-plans, et des méthodes paramétriques comme FGbuster, qui reposent sur la modélisation explicite des avant-plans.

Dans cette présentation, nous allons nous concentrer sur les méthodes paramétriques. Celles-ci nous permettent d'utiliser des modèles pour les avant-plans et d'améliorer la précision du processus de séparation.

:::

---

## On-going development of parametric component separation within the FURAX framework

::: {.columns}

::: {.column width="50%"}

#### Does everything fgbuster does but “better"
 - Uses the FURAX operators to represent linear algebra to efficient computing
 - Is written in JAX, hardware accelerated and have easy access to gradients

:::{.fragment fragment-index=1}

<br />

![](assets/CMB/Log_Like_bench.png){.nostretch fig-align="center" width="80%" style="border: 2px solid #000000;"}

:::

:::

::: {.column width="50%"}

#### Beyond fgbuster
 - Automatic cluster detection for spectral index parameters
  - Flexible likelihood model (can be extended to include more components and different objective functions)

:::{.fragment fragment-index=1}

![](assets/CMB/Comp-sep-patches.png){.nostretch fig-align="center" width="80%" style="border: 2px solid #000000;"}

:::

:::

:::

---

##  On-going development of parametric component separation within the FURAX framework {style="font-size: 22px;"}

:::{.columns}

:::{.column width="50%"}

:::{.fragment fragment-index=1}

#### Creating a Mixing Matrix Operator for SED evaluation

```python
from furax.seds import CMBOperator,DustOperator,\
                       SynchrotronOperator


def make_A(TEMP_D , BETA_D , BETA_S):
  cmb = CMBOperator(nu, in_structure)
  dust = DustOperator(nu , TEMP_D , BETA_D)
  synchrotron = SynchrotronOperator(nu , BETA_S)

  sed = BlockDiagonalOperator({
          'cmb': cmb,
          'dust': dust,
          'synchrotron': synchrotron
      })
  return sed(s)
```

:::

:::

:::{.column width="50%"}

:::{.fragment fragment-index=2}

#### Trivial construction of a spectral likelihood functions

```python
@jax.jit
def negative_log_prob(params, d):
  A = make_A(params['TEMP_D'], 
             params['BETA_D'], 
             params['BETA_S'])

  x = (A.T @ invN)(d)
  l = jax.tree.map(lambda a, b: a @ b, x, (A.T @ invN @ A).I(x))
  summed_log_prob = jax.tree.reduce(operator.add, l)

  return -summed_log_prob 
```

:::

:::

:::

<br />
<br />

:::{.fragment fragment-index=3}

:::{.solutionbox}

:::{.solutionbox-header style="font-size: 22px;"}

Easy to evaluate and extended

:::

::::{.solutionbox-body style="font-size: 20px;"}

- The likelihood function is readily available and can be easily extended to include more components or different objective functions.
- Easy access to gradients and hessians for optimization.

::::

:::

:::


## Atmosphere decontamination using time-domain component separation for the SO

**__Science goal:__** Characterise the observed atmospheric template from the recoded time-ordered data to separate the atmosphere 
from the sky signal we are after.

#### Data Model

:::{.columns}

:::{.column width="50%"}

datm = A(PWV) P(wx, wy) satm + n

datm : atmospheric time-ordered data recoded by our telescope
A(PWV)
P(wx, wy)
satm atmospheric template
n noise

:::

:::



#### Spectral likelihood

⟨𝒮spec(wx, wy, PWV ∣⃗datm)⟩= ⃗dT
atm (AP) ((AP)TN−1(AP))−1 (AP)TN−1 ⃗datm

