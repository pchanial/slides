---
title: "FURAX: a modular JAX toolbox for solving inverse problems in science "

author:
  - "Pierre Chanial, Wassim Kabalan, Simon Biquart"

format:
  revealjs:
    theme: [default, css/custom.scss]
    incremental: false   
    transition: slide
    background-transition: slide
    presentation-size: max-scale
    highlight-style: github
    slide-number: true
    template-partials:
      - css/title-slide.html
output: revealjs

title-slide-attributes:
  data-background-image: "assets/Wallpaper-datacenter-tetris.png"
  data-background-size: fill
  data-background-opacity: "0.2"


logo1 : '
<div style="display: flex; justify-content: space-around; align-items: center; layout-valign="middle">
  <img src="assets/Logos/Furax_logo_transparent.png" style="width: 25%;"/>
  <img src="assets/Logos/JaxLogo.png" style="width: 15%;"/>
  <img src="assets/Logos/Python.png" style="width: 20%;"/>
</div>
<div style="display: flex; justify-content: space-around; align-items: center; layout-valign="middle">
  <img src="assets/Logos/APC.png" style="width: 15%;"/>
  <img src="assets/Logos/scipol.png" style="width: 15%;"/>
  <img src="assets/Logos/ERC.svg" style="width: 15%;"/>
  <img src="assets/Logos/CNRS.svg" style="width: 15%;"/>
</div>
'
---

## FURAX Library

:::{.solutionbox}

::::{.solutionbox-body style="font-size: 22px; border-radius: 10px; border: 2px solid #521463;"}

- <span style="color:#521463; font-size: 28px;">**Motivations and Goals**</span>: Why FURAX ?
<br />
<br />
- <span style="color:#521463; font-size: 28px;">**FURAX Operators**</span>: Presentation of the FURAX building blocks: the Operators.
<br />
<br />
- <span style="color:#521463; font-size: 28px;">**Optimizations**</span>: High-level algebraic reductions with FURAX.
<br />
<br />
- <span style="color:#521463; font-size: 28px;">**CMB Applications**</span>: From map-making to component separation.
::::

:::



# Motivations and Goals {style="font-size: 35px; align=center;"}


# FURAX Building Blocks {style="font-size: 35px; align=center;"}

## AbstractLinearOperator Class

This class provides:

| Operation   | FURAX | Comment |
|-------------|-------|---------|
| Addition    | `A + B` |   |
| Composition | `A @ B` |   |
| Multiplication by scalar | `k * A` | Returns the composition of a HomothetyOperator and A|
| Transpose   | `A.T`  |  Through JAX autodiff, but can be overriden |
| Inverse     | `A.I` | Unless specifically implemented, use CG but it can be configured using a context manager |


# Multi-level Optimizations {style="font-size: 35px; align=center;"}

## JAX GPU Compilation Chain

![From the Python code to the GPU-native code](assets/jax-compilation-chain.png){fig-align="center" width="120%"}

## XLA simplifications

:::: {.columns}

::: {.column width="50%"}


#### **Mathematical identities**
- $a\times 0 = a - a = 0$
- $a - 0 = a\times 1 = a / 1 = a^1 = a$
- $a^{-1} = 1/a$, $a^{1/2} = \sqrt{a}$
- $-(-x) = x$
- $(-a)(-b) = ab$
- $ac + bc = (a+b)c$
- $a / const = a \times (1 / const)$
- $(a + c1) + (b + c2) =  a + b + (c1 + c2)$
- $(a / b) / (c / d) = ad / bc$
- $\ln e^x = x$
- $\exp a \exp b = \exp(a+b)$
- $a / \exp b = a \exp(-b)$

:::

::: {.column width="50%"}

#### **Array manipulations**

  - slicing
  - reshaping
  - broadcasting
  - transposition
  - bitcast
  - copies

#### **Ol' Digger's tricks**

  - $a^2 = a \times a$, $a^3 = a \times a \times a$
  - $a / b = a$>>$\log_2 b$ if b is a power of 2
  - $a \mod b = a \& (b - 1)$ if b is a power of 2

:::

and many more (see xla/hlo/transforms/simplifiers/algebraic_simplifier.cc)

:::

::::

## XLA Common Subexpression Elimination (CSE)

:::: {.columns}

::: {.column width="50%"}

```python
import jax
import jax.numpy as jnp

@jax.jit
def func_cse(theta):
    a = jnp.sin(theta)
    b = jnp.sin(theta) + 1
    return a + b
 ```
:::

::: {.column width="50%"}

::: {.fragment fragment-index=1}

![Compiled StableHLO representation](assets/hlo/hlo-func-cse.png){fig-align="center" width="60%"}

:::

:::

::::

## Dead Code Elimination (DCE)

:::: {.columns}

::: {.column width="50%"}

```python
import jax
import jax.numpy as jnp

@jax.jit
def func(x):
    unused = jnp.sin(x)
    y = jnp.exp(x)
    return y[0]
```

::: {.fragment fragment-index=2}

![Full computation vs DCE](assets/hlo/bench-dce.png){fig-align="center" width="190%"}

:::

:::

::: {.column width="50%"}

::: {.fragment fragment-index=1}

![Compiled StableHLO representation](assets/hlo/hlo-func-dce.png){fig-align="center" width="60%"}

:::

:::

::::

## JAX GPU Compilation Chain with FURAX

![From the Python code to the GPU-native code](assets/jax-compilation-chain-with-furax.png){fig-align="center" width="120%"}


## FURAX Algebraic Reductions: Pointing Matrix

::: {style="font-size: 20px;"}

When the time-time noise covariance matrix $N$ is diagonal and $P$ is a "one-to-one" intensity projection matrix:

$$
P = 
\begin{bmatrix}
0 & \cdots & 0 & 1 & 0 & \cdots & 0 \\
0 & 1 & 0 & \cdots & 0 & 0 & \cdots & 0 \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
1 & 0 & \cdots & 0 & 0 & \cdots & 0 \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
0 & 0 & \cdots & 0 & 1 & 0 & \cdots & 0 \\
\end{bmatrix},
$$
the product $P^{\textrm{T}} N^{-1} P$ is diagonal and can therefore be easily inverted (for pixel-pixel covariance matrix or preconditioning). Each term is related to the number of times a pixel of the map has been observed.

For IQU maps, the product is block diagonal, with 3x3 blocks that can also be easily inverted.

By adding a **rule** for this operation, we've seen an performance improvement by more than a **factor of 10** in the forward application (WIP, currently only for $N$ scalar).

:::

## FURAX Algebraic Reductions: Composition of Rotation Matrices


```python
import jax
import jax.numpy as jnp

def rot(x, y, theta):
    rotated_x = x * jnp.cos(theta) - y * jnp.sin(theta)
    rotated_y = x * jnp.sin(theta) + y * jnp.cos(theta)
    return rotated_x, rotated_y

@jax.jit
def func(x, y, theta1, theta2):
    x, y = rot(x, y, theta=theta1)
    return rot(x, y, theta=theta2)
  ```

::: {.fragment fragment-index=1}

![Compiled StableHLO representation](assets/hlo/hlo-rot.png){fig-align="center" width="60%"}

:::

## FURAX Algebraic Reductions: Composition of Rotation Matrices


```python
import jax
import jax.numpy as jnp

def rot(x, y, theta):
    rotated_x = x * jnp.cos(theta) - y * jnp.sin(theta)
    rotated_y = x * jnp.sin(theta) + y * jnp.cos(theta)
    return rotated_x, rotated_y

@jax.jit
def func(x, y, theta1, theta2):
    return rot(x, y, theta=theta1 + theta2)
  ```

::: {.fragment fragment-index=1}

![Compiled StableHLO representation](assets/hlo/hlo-rot-furax.png){fig-align="center" width="60%"}

:::

## FURAX Algebraic Reductions: Instrument Acquisition

Given this modeling of the acquisition, using an ideal linear polarizer and an ideal half wave plate:
$$
H = C_{\textrm{LP}} \, R_{2\theta} \, R_{-2\phi} \, C_{\textrm{HWP}} \, R_{2\phi} \, R_{2\psi} \, P
$$
with

- $\theta$: detector angle
- $\phi$: HWP rotation angle
- $\psi$: telescope rotation angle

FURAX reduces this expression to:

$$
H = C_{\textrm{LP}} \, R_{-2\theta + 4\phi + 2\psi}\, P
$$

# CMB Applications {style="font-size: 35px; align=center;"}
