---
title: "FURAX: a modular JAX toolbox for solving inverse problems in science "

author:
  - "Pierre Chanial, Wassim Kabalan, Simon Biquart"

format:
  revealjs:
    theme: [default, css/custom.scss]
    incremental: false   
    transition: slide
    background-transition: slide
    presentation-size: max-scale
    highlight-style: github
    slide-number: true
    template-partials:
      - css/title-slide.html
output: revealjs

title-slide-attributes:
  data-background-image: "assets/Wallpaper-datacenter-tetris.png"
  data-background-size: fill
  data-background-opacity: "0.2"


logo1 : '
<div style="display: flex; justify-content: space-around; align-items: center; layout-valign="middle">
  <img src="assets/Logos/Furax_logo_transparent.png" style="width: 25%;"/>
  <img src="assets/Logos/JaxLogo.png" style="width: 15%;"/>
  <img src="assets/Logos/Python.png" style="width: 20%;"/>
</div>
<div style="display: flex; justify-content: space-around; align-items: center; layout-valign="middle">
  <img src="assets/Logos/APC.png" style="width: 15%;"/>
  <img src="assets/Logos/scipol.png" style="width: 15%;"/>
  <img src="assets/Logos/ERC.svg" style="width: 15%;"/>
  <img src="assets/Logos/CNRS.svg" style="width: 15%;"/>
</div>
'
---

## FURAX Library

:::{.solutionbox}

::::{.solutionbox-body style="font-size: 22px; border-radius: 10px; border: 2px solid #521463;"}

- <span style="color:#521463; font-size: 28px;">**Motivations and Goals**</span>: Why FURAX ?
<br />
<br />
- <span style="color:#521463; font-size: 28px;">**FURAX Operators**</span>: Presentation of the FURAX building blocks: the Operators.
<br />
<br />
- <span style="color:#521463; font-size: 28px;">**Optimizations**</span>: High-level algebraic reductions with FURAX.
<br />
<br />
- <span style="color:#521463; font-size: 28px;">**CMB Applications**</span>: From map-making to component separation.
::::

:::



# Motivations and Goals {style="font-size: 35px; align=center;"}


# FURAX Building Blocks {style="font-size: 35px; align=center;"}

## FURAX Operators

<br>

The base class `AbstractLinearOperator` provides a default implementation for the usual linear algebra operations.

<br>

::: {style="font-size: 18px;"}

| Operation   | FURAX | Comment |
|-------------|-------|---------|
| Addition    | `A + B` |   |
| Composition | `A @ B` |   |
| Multiplication by scalar | `k * A` | Returns the composition of a HomothetyOperator and A|
| Transpose   | `A.T`  |  Through JAX autodiff, but can be overriden |
| Inverse     | `A.I` | By default, use CG but it can be overriden or configured using a context manager |
| Block Assembly | `BlockColumnOperator([A, B])` `BlockDiagonalOperator([A, B])` `BlockRowOperator([A, B])` | Handle any PyTree of Operators: `Block*Operator({'a': A, 'b': B})`|
| Flattened dense matrix | `A.as_matrix()` | |
| Algebraic reduction | `A.reduce()` | |

: {tbl-colwidths="[25,35,40]"}

:::

## FURAX Operators {style="font-size: 18px;"}

<br/>
<br/>

::: {.columns}

::: {.column width="60%"}

::: {.solutionbox}

:::{.solutionbox-body style="font-size: 17px;"}

| Generic Operator                | Description |
|---------------------------------|-------------|
| `IdentityOperator`              |             |
| `HomothetyOperator`             |             |
| `DiagonalOperator`              |             |
| `BroadcastDiagonalOperator`     | Non-square operator for broadcasting |
| `TensorOperator`    | For dense matrix operations |
| `IndexOperator`                 | Used for projecting skies onto time-ordered series|
| `MoveAxisOperator`              |             |
| `ReshapeOperator`               |             |
| `RavelOperator`                 |             |
| `SymmetricBandToeplitzOperator` | Methods: direct, FFT, overlap and save |
| `Block*Operator` | Block assembly operators (column, diagonal, row)|

:::

:::


:::

::: {.column width="40%"}

::: {.solutionbox}

:::{.solutionbox-body style="font-size: 17px;"}


| Applied Operator          | Description |
|---------------------------|-------------|
| `QURotationOperator`      |             |
| `HWPOperator`             | Ideal HWP   |
| `LinearPolarizerOperator` | Ideal linear polarizer |
| `CMBOperator`             | Parametrized CMB SED |
| `DustOperator`            | Parametrized dust SED |
| `SynchrotronOperator`     | Parametrized synchrotron SED |

:::

:::

:::



:::

# Multi-level Optimizations {style="font-size: 35px;"}

## JAX GPU Compilation Chain

<br/>
<br/>
<br/>
<br/>
<br/>

![From the Python code to the GPU-native code](assets/jax-compilation-chain.png){.nostrech fig-align="center" width="100%"}

## XLA simplifications

:::: {.columns}

::: {.column width="50%"}


#### **Mathematical identities**
- $a\times 0 = a - a = 0$
- $a - 0 = a\times 1 = a / 1 = a^1 = a$
- $a^{-1} = 1/a$, $a^{1/2} = \sqrt{a}$
- $-(-x) = x$
- $(-a)(-b) = ab$
- $ac + bc = (a+b)c$
- $a / const = a \times (1 / const)$
- $(a + c1) + (b + c2) =  a + b + (c1 + c2)$
- $(a / b) / (c / d) = ad / bc$
- $\ln e^x = x$
- $\exp a \exp b = \exp(a+b)$
- $a / \exp b = a \exp(-b)$

:::

::: {.column width="50%"}

#### **Array manipulations**

  - slicing
  - reshaping
  - broadcasting
  - transposition
  - bitcast
  - copies

#### **Ol' Digger's tricks**

  - $a^2 = a \times a$, $a^3 = a \times a \times a$
  - $a / b = a$>>$\log_2 b$ if b is a power of 2
  - $a \mod b = a \& (b - 1)$ if b is a power of 2

:::

and many more (see xla/hlo/transforms/simplifiers/algebraic_simplifier.cc)

:::

::::

## XLA Common Subexpression Elimination (CSE)

:::: {.columns}

::: {.column width="50%"}

```python
import jax
import jax.numpy as jnp

@jax.jit
def func_cse(theta):
    a = jnp.sin(theta)
    b = jnp.sin(theta) + 1
    return a + b
 ```
:::

::: {.column width="50%"}

::: {.fragment fragment-index=1}

![Compiled StableHLO representation](assets/hlo/hlo-func-cse.png){fig-align="center" width="60%"}

:::

:::

::::

## Dead Code Elimination (DCE)

:::: {.columns}

::: {.column width="50%"}

```python
import jax
import jax.numpy as jnp

@jax.jit
def func(x):
    unused = jnp.sin(x)
    y = jnp.exp(x)
    return y[0]
```

::: {.fragment fragment-index=2}

![Full computation vs DCE](assets/hlo/bench-dce.png){fig-align="center" width="190%"}

:::

:::

::: {.column width="50%"}

::: {.fragment fragment-index=1}

![Compiled StableHLO representation](assets/hlo/hlo-func-dce.png){fig-align="center" width="60%"}

:::

:::

::::

## JAX GPU Compilation Chain with FURAX

![From the Python code to the GPU-native code](assets/jax-compilation-chain-with-furax.png){fig-align="center" width="120%"}


## FURAX Algebraic Reductions: Pointing Matrix

::: {style="font-size: 20px;"}

When the time-time noise covariance matrix $N$ is diagonal and $P$ is a "one-to-one" intensity projection matrix:

$$
P = 
\begin{bmatrix}
0 & \cdots & 0 & 1 & 0 & \cdots & 0 \\
0 & 1 & 0 & \cdots & 0 & 0 & \cdots & 0 \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
1 & 0 & \cdots & 0 & 0 & \cdots & 0 \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
0 & 0 & \cdots & 0 & 1 & 0 & \cdots & 0 \\
\end{bmatrix},
$$
the product $P^{\textrm{T}} N^{-1} P$ is diagonal and can therefore be easily inverted (for pixel-pixel covariance matrix or preconditioning). Each term is related to the number of times a pixel of the map has been observed.

For IQU maps, the product is block diagonal, with 3x3 blocks that can also be easily inverted.

By adding a **rule** for this operation, we've seen an performance improvement by more than a **factor of 10** in the forward application (WIP, currently only for $N$ scalar).

:::

## FURAX Algebraic Reductions: Composition of Rotation Matrices


```python
import jax
import jax.numpy as jnp

def rot(x, y, theta):
    rotated_x = x * jnp.cos(theta) - y * jnp.sin(theta)
    rotated_y = x * jnp.sin(theta) + y * jnp.cos(theta)
    return rotated_x, rotated_y

@jax.jit
def func(x, y, theta1, theta2):
    x, y = rot(x, y, theta=theta1)
    return rot(x, y, theta=theta2)
  ```

::: {.fragment fragment-index=1}

![Compiled StableHLO representation](assets/hlo/hlo-rot.png){fig-align="center" width="60%"}

:::

## FURAX Algebraic Reductions: Composition of Rotation Matrices


```python
import jax
import jax.numpy as jnp

def rot(x, y, theta):
    rotated_x = x * jnp.cos(theta) - y * jnp.sin(theta)
    rotated_y = x * jnp.sin(theta) + y * jnp.cos(theta)
    return rotated_x, rotated_y

@jax.jit
def func(x, y, theta1, theta2):
    return rot(x, y, theta=theta1 + theta2)
  ```

::: {.fragment fragment-index=1}

![Compiled StableHLO representation](assets/hlo/hlo-rot-furax.png){fig-align="center" width="60%"}

:::

## FURAX Algebraic Reductions: Block Assembly

::: {style="font-size: 15px;"}

<br>
<br>

| Operation | Reduction |
|---------------------------------|-------------|
| `BlockDiagonalOperator([D1, D2]) @ BlockColumnOperator([C1, C2])`              | `BlockColumnOperator([D1 @ C1, D2 @ C2])`|
| `BlockRowOperator([R1, R2]) @ BlockDiagonalOperator([D1, D2])`              | `BlockRowOperator([R1 @ D1, R2 @ D2])`|
| `BlockRowOperator([R1, R2]) @ BlockColumnOperator([C1, C2])`              | `R1 @ C1 + R2 @ C2`|

: {tbl-colwidths="[60,40]"}

:::

<br>
<br>

#### Practical usage: combining observations

Given two observations
$$
P =
\begin{bmatrix}
P_1 \\
P_2
\end{bmatrix}, \quad
N^{-1} =
\begin{bmatrix}
N_1^{-1} & 0 \\
0 & N_2^{-1}
\end{bmatrix},
$$

The combining results in
$$
P^T N^{-1} P = P_1^T N_1^{-1} P_1 + P_2^T N_2^{-1} P_2.
$$


## FURAX Algebraic Reductions: Instrument Acquisition

Given this modeling of the acquisition, using an ideal linear polarizer and an ideal half wave plate:
$$
H = C_{\textrm{LP}} \, R_{2\theta} \, R_{-2\phi} \, C_{\textrm{HWP}} \, R_{2\phi} \, R_{2\psi} \, P
$$
with

- $\theta$: detector angle
- $\phi$: HWP rotation angle
- $\psi$: telescope rotation angle

FURAX reduces this expression to:

$$
H = C_{\textrm{LP}} \, R_{-2\theta + 4\phi + 2\psi}\, P
$$

# CMB Applications {style="font-size: 35px; align=center;"}

---

## Component Seperation {style="font-size: 22px;"}

::: {.columns}

::: {.column width="50%"}

![](assets/CMB/CMB-Planck.png){.nostretch fig-align="center" width="35%"}

::: {.fragment fragment-index=1}

![](assets/CMB/Plus_symbol.svg){.nostretch fig-align="center" width="10%"}

![](assets/CMB/dust_planck.png){.nostretch fig-align="center" width="35%"}

:::

::: {.fragment fragment-index=2}

![](assets/CMB/Plus_symbol.svg){.nostretch fig-align="center" width="10%"}

![](assets/CMB/synch-planck.png){.nostretch fig-align="center" width="35%"}

:::

:::

::: {.column width="50%"}

- The **Cosmic Microwave Background (CMB)** signal is obscured by various **foregrounds**, making it challenging to detect the true cosmological information.

::: {.fragment fragment-index=1}
- **Dust**: Emission from galactic dust adds significant noise to the CMB, particularly affecting polarization measurements.
:::

::: {.fragment fragment-index=2}
- **Synchrotron Radiation**: Electrons spiraling in the galaxy's magnetic fields produce synchrotron radiation, another major contaminant.
:::

::: {.fragment fragment-index=3}

:::{.solutionbox}

:::{.solutionbox-header style="font-size: 22px;"}

**Component seperation methods**

:::

::::{.solutionbox-body style="font-size: 2Opx;"}

- **Blind Methods**: Like **SMICA** (Spectral Matching Independent Component Analysis)
- **Parametric Methods**: Like **FGbuster** (Foreground Buster)

::::

:::

:::

:::

:::

::: {.notes}

Le signal du fond diffus cosmologique, ou CMB, est en r√©alit√© obscurci par plusieurs avant-plans, ce qui rend difficile l'extraction des informations cosmologiques r√©elles.

L'un des contaminants principaux est la poussi√®re galactique. Cette poussi√®re √©met du rayonnement qui ajoute un bruit significatif au CMB, affectant particuli√®rement les mesures de polarisation.

**NEXT**

Un autre contaminant majeur est la radiation synchrotron. Elle est produite par des √©lectrons en spirale dans les champs magn√©tiques de notre galaxie, ce qui vient encore plus brouiller le signal cosmologique que l'on souhaite observer.

**AFTER**

Pour pouvoir extraire une valeur fiable du rapport $r$, il est crucial de s√©parer ou de "d√©mixer" ces composants. Le signal du CMB est m√™l√© √† diverses √©missions parasites.

 Il existe diff√©rentes m√©thodes pour cela, principalement des m√©thodes aveugles comme SMICA, qui fonctionnent sans connaissances pr√©alables des avant-plans, et des m√©thodes param√©triques comme FGbuster, qui reposent sur la mod√©lisation explicite des avant-plans.

Dans cette pr√©sentation, nous allons nous concentrer sur les m√©thodes param√©triques. Celles-ci nous permettent d'utiliser des mod√®les pour les avant-plans et d'am√©liorer la pr√©cision du processus de s√©paration.

:::

---

## On-going development of parametric component separation within the FURAX framework

::: {.columns}

::: {.column width="50%"}

#### Does everything fgbuster does but ‚Äúbetter"
 - Uses the FURAX operators to represent linear algebra to efficient computing
 - Is written in JAX, hardware accelerated and have easy access to gradients

:::{.fragment fragment-index=1}

<br />

![](assets/CMB/Log_Like_bench.png){.nostretch fig-align="center" width="80%" style="border: 2px solid #000000;"}

:::

:::

::: {.column width="50%"}

#### Beyond fgbuster
 - Automatic cluster detection for spectral index parameters
  - Flexible likelihood model (can be extended to include more components and different objective functions)

:::{.fragment fragment-index=1}

![](assets/CMB/Comp-sep-patches.png){.nostretch fig-align="center" width="80%" style="border: 2px solid #000000;"}

:::

:::

:::

---

##  On-going development of parametric component separation within the FURAX framework {style="font-size: 22px;"}

:::{.columns}

:::{.column width="50%"}

:::{.fragment fragment-index=1}

#### Creating a Mixing Matrix Operator for SED evaluation

```python
from furax.seds import CMBOperator,DustOperator,\
                       SynchrotronOperator


def make_A(TEMP_D , BETA_D , BETA_S):
  cmb = CMBOperator(nu, in_structure)
  dust = DustOperator(nu , TEMP_D , BETA_D)
  synchrotron = SynchrotronOperator(nu , BETA_S)

  sed = BlockDiagonalOperator({
          'cmb': cmb,
          'dust': dust,
          'synchrotron': synchrotron
      })
  return sed(s)
```

:::

:::

:::{.column width="50%"}

:::{.fragment fragment-index=2}

#### Trivial construction of a spectral likelihood functions

```python
@jax.jit
def negative_log_prob(params, d):
  A = make_A(params['TEMP_D'], 
             params['BETA_D'], 
             params['BETA_S'])

  x = (A.T @ invN)(d)
  l = jax.tree.map(lambda a, b: a @ b, x, (A.T @ invN @ A).I(x))
  summed_log_prob = jax.tree.reduce(operator.add, l)

  return -summed_log_prob 
```

:::

:::

:::

<br />
<br />

:::{.fragment fragment-index=3}

:::{.solutionbox}

:::{.solutionbox-header style="font-size: 22px;"}

Easy to evaluate and extended

:::

::::{.solutionbox-body style="font-size: 20px;"}

- The likelihood function is readily available and can be easily extended to include more components or different objective functions.
- Easy access to gradients and hessians for optimization.

::::

:::

:::


## Atmosphere decontamination using time-domain component separation for the SO

**__Science goal:__** Characterise the observed atmospheric template from the recoded time-ordered data to separate the atmosphere 
from the sky signal we are after.

#### Data Model

:::{.columns}

:::{.column width="50%"}

datm = A(PWV) P(wx, wy) satm + n

datm : atmospheric time-ordered data recoded by our telescope
A(PWV)
P(wx, wy)
satm atmospheric template
n noise

:::

:::



#### Spectral likelihood

‚ü®ùíÆspec(wx, wy, PWV ‚à£‚Éódatm)‚ü©= ‚ÉódT
atm (AP) ((AP)TN‚àí1(AP))‚àí1 (AP)TN‚àí1 ‚Éódatm

