[
  {
    "objectID": "iap2024/index.html#furax-library",
    "href": "iap2024/index.html#furax-library",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX Library",
    "text": "FURAX Library\n\n\n\nMotivations and Goals: Why FURAX ?  \nFURAX Operators: Presentation of the FURAX building blocks: the Operators.  \nOptimizations: High-level algebraic reductions with FURAX.  \nCMB Applications: From map-making to component separation."
  },
  {
    "objectID": "iap2024/index.html#furax-operators",
    "href": "iap2024/index.html#furax-operators",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX Operators",
    "text": "FURAX Operators\n\nThe base class AbstractLinearOperator provides a default implementation for the usual linear algebra operations.\n\n\n\n\n\n\n\n\n\n\nOperation\nFURAX\nComment\n\n\n\n\nAddition\nA + B\n\n\n\nComposition\nA @ B\n\n\n\nMultiplication by scalar\nk * A\nReturns the composition of a HomothetyOperator and A\n\n\nTranspose\nA.T\nThrough JAX autodiff, but can be overriden\n\n\nInverse\nA.I\nBy default, use CG but it can be overriden or configured using a context manager\n\n\nBlock Assembly\nBlockColumnOperator([A, B]) BlockDiagonalOperator([A, B]) BlockRowOperator([A, B])\nHandle any PyTree of Operators: Block*Operator({'a': A, 'b': B})\n\n\nFlattened dense matrix\nA.as_matrix()\n\n\n\nAlgebraic reduction\nA.reduce()"
  },
  {
    "objectID": "iap2024/index.html#furax-operators-1",
    "href": "iap2024/index.html#furax-operators-1",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX Operators",
    "text": "FURAX Operators\n\n\n\n\n\n\n\n\nGeneric Operator\nDescription\n\n\n\n\nIdentityOperator\n\n\n\nHomothetyOperator\n\n\n\nDiagonalOperator\n\n\n\nBroadcastDiagonalOperator\nNon-square operator for broadcasting\n\n\nTensorOperator\nFor dense matrix operations\n\n\nIndexOperator\nUsed for projecting skies onto time-ordered series\n\n\nMoveAxisOperator\n\n\n\nReshapeOperator\n\n\n\nRavelOperator\n\n\n\nSymmetricBandToeplitzOperator\nMethods: direct, FFT, overlap and save\n\n\nBlock*Operator\nBlock assembly operators (column, diagonal, row)\n\n\n\n\n\n\n\n\n\n\n\nApplied Operator\nDescription\n\n\n\n\nQURotationOperator\n\n\n\nHWPOperator\nIdeal HWP\n\n\nLinearPolarizerOperator\nIdeal linear polarizer\n\n\nCMBOperator\nParametrized CMB SED\n\n\nDustOperator\nParametrized dust SED\n\n\nSynchrotronOperator\nParametrized synchrotron SED"
  },
  {
    "objectID": "iap2024/index.html#jax-gpu-compilation-chain",
    "href": "iap2024/index.html#jax-gpu-compilation-chain",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "JAX GPU Compilation Chain",
    "text": "JAX GPU Compilation Chain\n    \n\nFrom the Python code to the GPU-native code"
  },
  {
    "objectID": "iap2024/index.html#xla-simplifications",
    "href": "iap2024/index.html#xla-simplifications",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "XLA simplifications",
    "text": "XLA simplifications\n\n\nMathematical identities\n\n\\(a\\times 0 = a - a = 0\\)\n\\(a - 0 = a\\times 1 = a / 1 = a^1 = a\\)\n\\(a^{-1} = 1/a\\), \\(a^{1/2} = \\sqrt{a}\\)\n\\(-(-x) = x\\)\n\\((-a)(-b) = ab\\)\n\\(ac + bc = (a+b)c\\)\n\\(a / const = a \\times (1 / const)\\)\n\\((a + c1) + (b + c2) =  a + b + (c1 + c2)\\)\n\\((a / b) / (c / d) = ad / bc\\)\n\\(\\ln e^x = x\\)\n\\(\\exp a \\exp b = \\exp(a+b)\\)\n\\(a / \\exp b = a \\exp(-b)\\)\n\n\nArray manipulations\n\nslicing\nreshaping\nbroadcasting\ntransposition\nbitcast\ncopies\n\nOl’ Digger’s tricks\n\n\\(a^2 = a \\times a\\), \\(a^3 = a \\times a \\times a\\)\n\\(a / b = a\\)&gt;&gt;\\(\\log_2 b\\) if b is a power of 2\n\\(a \\mod b = a \\& (b - 1)\\) if b is a power of 2\n\nand many more (see xla/hlo/transforms/simplifiers/algebraic_simplifier.cc)\n\n::::"
  },
  {
    "objectID": "iap2024/index.html#xla-common-subexpression-elimination-cse",
    "href": "iap2024/index.html#xla-common-subexpression-elimination-cse",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "XLA Common Subexpression Elimination (CSE)",
    "text": "XLA Common Subexpression Elimination (CSE)\n\n\nimport jax\nimport jax.numpy as jnp\n\n@jax.jit\ndef func_cse(theta):\n    a = jnp.sin(theta)\n    b = jnp.sin(theta) + 1\n    return a + b\n\n\n\n\n\nCompiled StableHLO representation"
  },
  {
    "objectID": "iap2024/index.html#dead-code-elimination-dce",
    "href": "iap2024/index.html#dead-code-elimination-dce",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "Dead Code Elimination (DCE)",
    "text": "Dead Code Elimination (DCE)\n\n\nimport jax\nimport jax.numpy as jnp\n\n@jax.jit\ndef func(x):\n    unused = jnp.sin(x)\n    y = jnp.exp(x)\n    return y[0]\n\n\n\n\nFull computation vs DCE\n\n\n\n\n\n\n\n\nCompiled StableHLO representation"
  },
  {
    "objectID": "iap2024/index.html#jax-gpu-compilation-chain-with-furax",
    "href": "iap2024/index.html#jax-gpu-compilation-chain-with-furax",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "JAX GPU Compilation Chain with FURAX",
    "text": "JAX GPU Compilation Chain with FURAX\n\nFrom the Python code to the GPU-native code"
  },
  {
    "objectID": "iap2024/index.html#furax-algebraic-reductions-pointing-matrix",
    "href": "iap2024/index.html#furax-algebraic-reductions-pointing-matrix",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX Algebraic Reductions: Pointing Matrix",
    "text": "FURAX Algebraic Reductions: Pointing Matrix\n\nWhen the time-time noise covariance matrix \\(N\\) is diagonal and \\(P\\) is a “one-to-one” intensity projection matrix:\n\\[\nP =\n\\begin{bmatrix}\n0 & \\cdots & 0 & 1 & 0 & \\cdots & 0 \\\\\n0 & 1 & 0 & \\cdots & 0 & 0 & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 & 0 & \\cdots & 0 & 0 & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n0 & 0 & \\cdots & 0 & 1 & 0 & \\cdots & 0 \\\\\n\\end{bmatrix},\n\\] the product \\(P^{\\textrm{T}} N^{-1} P\\) is diagonal and can therefore be easily inverted (for pixel-pixel covariance matrix or preconditioning). Each term is related to the number of times a pixel of the map has been observed.\nFor IQU maps, the product is block diagonal, with 3x3 blocks that can also be easily inverted.\nBy adding a rule for this operation, we’ve seen an performance improvement by more than a factor of 10 in the forward application (WIP, currently only for \\(N\\) scalar)."
  },
  {
    "objectID": "iap2024/index.html#furax-algebraic-reductions-composition-of-rotation-matrices",
    "href": "iap2024/index.html#furax-algebraic-reductions-composition-of-rotation-matrices",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX Algebraic Reductions: Composition of Rotation Matrices",
    "text": "FURAX Algebraic Reductions: Composition of Rotation Matrices\nimport jax\nimport jax.numpy as jnp\n\ndef rot(x, y, theta):\n    rotated_x = x * jnp.cos(theta) - y * jnp.sin(theta)\n    rotated_y = x * jnp.sin(theta) + y * jnp.cos(theta)\n    return rotated_x, rotated_y\n\n@jax.jit\ndef func(x, y, theta1, theta2):\n    x, y = rot(x, y, theta=theta1)\n    return rot(x, y, theta=theta2)\n\n\n\n\nCompiled StableHLO representation"
  },
  {
    "objectID": "iap2024/index.html#furax-algebraic-reductions-composition-of-rotation-matrices-1",
    "href": "iap2024/index.html#furax-algebraic-reductions-composition-of-rotation-matrices-1",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX Algebraic Reductions: Composition of Rotation Matrices",
    "text": "FURAX Algebraic Reductions: Composition of Rotation Matrices\nimport jax\nimport jax.numpy as jnp\n\ndef rot(x, y, theta):\n    rotated_x = x * jnp.cos(theta) - y * jnp.sin(theta)\n    rotated_y = x * jnp.sin(theta) + y * jnp.cos(theta)\n    return rotated_x, rotated_y\n\n@jax.jit\ndef func(x, y, theta1, theta2):\n    return rot(x, y, theta=theta1 + theta2)\n\n\n\n\nCompiled StableHLO representation"
  },
  {
    "objectID": "iap2024/index.html#furax-algebraic-reductions-block-assembly",
    "href": "iap2024/index.html#furax-algebraic-reductions-block-assembly",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX Algebraic Reductions: Block Assembly",
    "text": "FURAX Algebraic Reductions: Block Assembly\n\n \n\n\n\n\n\n\n\nOperation\nReduction\n\n\n\n\nBlockDiagonalOperator([D1, D2]) @ BlockColumnOperator([C1, C2])\nBlockColumnOperator([D1 @ C1, D2 @ C2])\n\n\nBlockRowOperator([R1, R2]) @ BlockDiagonalOperator([D1, D2])\nBlockRowOperator([R1 @ D1, R2 @ D2])\n\n\nBlockRowOperator([R1, R2]) @ BlockColumnOperator([C1, C2])\nR1 @ C1 + R2 @ C2\n\n\n\n\n \nPractical usage: combining observations\nGiven two observations \\[\nP =\n\\begin{bmatrix}\nP_1 \\\\\nP_2\n\\end{bmatrix}, \\quad\nN^{-1} =\n\\begin{bmatrix}\nN_1^{-1} & 0 \\\\\n0 & N_2^{-1}\n\\end{bmatrix},\n\\]\nThe combining results in \\[\nP^T N^{-1} P = P_1^T N_1^{-1} P_1 + P_2^T N_2^{-1} P_2.\n\\]"
  },
  {
    "objectID": "iap2024/index.html#furax-algebraic-reductions-instrument-acquisition",
    "href": "iap2024/index.html#furax-algebraic-reductions-instrument-acquisition",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX Algebraic Reductions: Instrument Acquisition",
    "text": "FURAX Algebraic Reductions: Instrument Acquisition\nGiven this modeling of the acquisition, using an ideal linear polarizer and an ideal half wave plate: \\[\nH = C_{\\textrm{LP}} \\, R_{2\\theta} \\, R_{-2\\phi} \\, C_{\\textrm{HWP}} \\, R_{2\\phi} \\, R_{2\\psi} \\, P\n\\] with\n\n\\(\\theta\\): detector angle\n\\(\\phi\\): HWP rotation angle\n\\(\\psi\\): telescope rotation angle\n\nFURAX reduces this expression to:\n\\[\nH = C_{\\textrm{LP}} \\, R_{-2\\theta + 4\\phi + 2\\psi}\\, P\n\\]"
  },
  {
    "objectID": "iap2024/index.html#component-seperation",
    "href": "iap2024/index.html#component-seperation",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "Component Seperation",
    "text": "Component Seperation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Cosmic Microwave Background (CMB) signal is obscured by various foregrounds, making it challenging to detect the true cosmological information.\n\n\n\nDust: Emission from galactic dust adds significant noise to the CMB, particularly affecting polarization measurements.\n\n\n\n\nSynchrotron Radiation: Electrons spiraling in the galaxy’s magnetic fields produce synchrotron radiation, another major contaminant.\n\n\n\n\n\nComponent seperation methods\n\n\n\nBlind Methods: Like SMICA (Spectral Matching Independent Component Analysis)\nParametric Methods: Like FGbuster (Foreground Buster)\n\n\n\n\n\n\nLe signal du fond diffus cosmologique, ou CMB, est en réalité obscurci par plusieurs avant-plans, ce qui rend difficile l’extraction des informations cosmologiques réelles.\nL’un des contaminants principaux est la poussière galactique. Cette poussière émet du rayonnement qui ajoute un bruit significatif au CMB, affectant particulièrement les mesures de polarisation.\nNEXT\nUn autre contaminant majeur est la radiation synchrotron. Elle est produite par des électrons en spirale dans les champs magnétiques de notre galaxie, ce qui vient encore plus brouiller le signal cosmologique que l’on souhaite observer.\nAFTER\nPour pouvoir extraire une valeur fiable du rapport \\(r\\), il est crucial de séparer ou de “démixer” ces composants. Le signal du CMB est mêlé à diverses émissions parasites.\nIl existe différentes méthodes pour cela, principalement des méthodes aveugles comme SMICA, qui fonctionnent sans connaissances préalables des avant-plans, et des méthodes paramétriques comme FGbuster, qui reposent sur la modélisation explicite des avant-plans.\nDans cette présentation, nous allons nous concentrer sur les méthodes paramétriques. Celles-ci nous permettent d’utiliser des modèles pour les avant-plans et d’améliorer la précision du processus de séparation."
  },
  {
    "objectID": "iap2024/index.html#on-going-development-of-parametric-component-separation-within-the-furax-framework",
    "href": "iap2024/index.html#on-going-development-of-parametric-component-separation-within-the-furax-framework",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "On-going development of parametric component separation within the FURAX framework",
    "text": "On-going development of parametric component separation within the FURAX framework\n\n\nDoes everything fgbuster does but “better”\n\nUses the FURAX operators to represent linear algebra to efficient computing\nIs written in JAX, hardware accelerated and have easy access to gradients\n\n\n\n\n\n\n\n\n\n\nBeyond fgbuster\n\nAutomatic cluster detection for spectral index parameters\nFlexible likelihood model (can be extended to include more components and different objective functions)"
  },
  {
    "objectID": "iap2024/index.html#on-going-development-of-parametric-component-separation-within-the-furax-framework-1",
    "href": "iap2024/index.html#on-going-development-of-parametric-component-separation-within-the-furax-framework-1",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "On-going development of parametric component separation within the FURAX framework",
    "text": "On-going development of parametric component separation within the FURAX framework\n\n\n\n\nCreating a Mixing Matrix Operator for SED evaluation\nfrom furax.seds import CMBOperator,DustOperator,\\\n                       SynchrotronOperator\n\n\ndef make_A(TEMP_D , BETA_D , BETA_S):\n  cmb = CMBOperator(nu, in_structure)\n  dust = DustOperator(nu , TEMP_D , BETA_D)\n  synchrotron = SynchrotronOperator(nu , BETA_S)\n\n  sed = BlockDiagonalOperator({\n          'cmb': cmb,\n          'dust': dust,\n          'synchrotron': synchrotron\n      })\n  return sed(s)\n\n\n\n\nTrivial construction of a spectral likelihood functions\n@jax.jit\ndef negative_log_prob(params, d):\n  A = make_A(params['TEMP_D'], \n             params['BETA_D'], \n             params['BETA_S'])\n\n  x = (A.T @ invN)(d)\n  l = jax.tree.map(lambda a, b: a @ b, x, (A.T @ invN @ A).I(x))\n  summed_log_prob = jax.tree.reduce(operator.add, l)\n\n  return -summed_log_prob \n\n\n \n\n\n\nEasy to evaluate and extended\n\n\n\nThe likelihood function is readily available and can be easily extended to include more components or different objective functions.\nEasy access to gradients and hessians for optimization."
  }
]