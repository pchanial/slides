[
  {
    "objectID": "iap2024/index.html#furax-library",
    "href": "iap2024/index.html#furax-library",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX Library",
    "text": "FURAX Library\n\n\n\nGoals: Why FURAX ?  \nFURAX Operators: Presentation of the FURAX building blocks: the Operators.  \nOptimizations: High-level algebraic reductions with FURAX.  \nCMB Applications: From map-making to component separation."
  },
  {
    "objectID": "iap2024/index.html#jax-gpu-compilation-chain",
    "href": "iap2024/index.html#jax-gpu-compilation-chain",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "JAX GPU Compilation Chain",
    "text": "JAX GPU Compilation Chain\n\nFrom the Python code to the GPU-native code"
  },
  {
    "objectID": "iap2024/index.html#xla-simplifications",
    "href": "iap2024/index.html#xla-simplifications",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "XLA simplifications",
    "text": "XLA simplifications\n\n\nMathematical identities\n\n\\(a\\times 0 = a - a = 0\\)\n\\(a - 0 = a\\times 1 = a / 1 = a^1 = a\\)\n\\(a^{-1} = 1/a\\), \\(a^{1/2} = \\sqrt{a}\\)\n\\(-(-x) = x\\)\n\\((-a)(-b) = ab\\)\n\\(ac + bc = (a+b)c\\)\n\\(a / const = a \\times (1 / const)\\)\n\\((a + c1) + (b + c2) =  a + b + (c1 + c2)\\)\n\\((a / b) / (c / d) = ad / bc\\)\n\\(\\ln e^x = x\\)\n\\(\\exp a \\exp b = \\exp(a+b)\\)\n\\(a / \\exp b = a \\exp(-b)\\)\n\n\nArray manipulations\n\nslicing\nreshaping\nbroadcasting\ntransposition\nbitcast\ncopies\n\nOl’ Digger’s tricks\n\n\\(a^2 = a \\times a\\), \\(a^3 = a \\times a \\times a\\)\n\\(a / b = a\\)&gt;&gt;\\(\\log_2 b\\) if b is a power of 2\n\\(a \\mod b = a \\& (b - 1)\\) if b is a power of 2\n\nand many more (see xla/hlo/transforms/simplifiers/algebraic_simplifier.cc)\n\n::::"
  },
  {
    "objectID": "iap2024/index.html#xla-common-subexpression-elimination-cse",
    "href": "iap2024/index.html#xla-common-subexpression-elimination-cse",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "XLA Common Subexpression Elimination (CSE)",
    "text": "XLA Common Subexpression Elimination (CSE)\n\n\nimport jax\nimport jax.numpy as jnp\n\n@jax.jit\ndef func_cse(theta):\n    a = jnp.sin(theta)\n    b = jnp.sin(theta) + 1\n    return a + b\n\n\n\n\n\nCompiled StableHLO representation"
  },
  {
    "objectID": "iap2024/index.html#dead-code-elimination-dce",
    "href": "iap2024/index.html#dead-code-elimination-dce",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "Dead Code Elimination (DCE)",
    "text": "Dead Code Elimination (DCE)\n\n\nimport jax\nimport jax.numpy as jnp\n\n@jax.jit\ndef func(x):\n    unused = jnp.sin(x)\n    y = jnp.exp(x)\n    return y[0]\n\n\n\n\nFull computation vs DCE\n\n\n\n\n\n\n\n\nCompiled StableHLO representation"
  },
  {
    "objectID": "iap2024/index.html#jax-gpu-compilation-chain-with-furax",
    "href": "iap2024/index.html#jax-gpu-compilation-chain-with-furax",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "JAX GPU Compilation Chain with FURAX",
    "text": "JAX GPU Compilation Chain with FURAX\n\nFrom the Python code to the GPU-native code"
  },
  {
    "objectID": "iap2024/index.html#furax-algebraic-reductions-pointing-matrix",
    "href": "iap2024/index.html#furax-algebraic-reductions-pointing-matrix",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX Algebraic Reductions: Pointing Matrix",
    "text": "FURAX Algebraic Reductions: Pointing Matrix\n\nWhen the time-time noise covariance matrix \\(N\\) is diagonal and \\(P\\) is a “one-to-one” intensity projection matrix:\n\\[\nP =\n\\begin{bmatrix}\n0 & \\cdots & 0 & 1 & 0 & \\cdots & 0 \\\\\n0 & 1 & 0 & \\cdots & 0 & 0 & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 & 0 & \\cdots & 0 & 0 & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n0 & 0 & \\cdots & 0 & 1 & 0 & \\cdots & 0 \\\\\n\\end{bmatrix},\n\\] the product \\(P^{\\textrm{T}} N^{-1} P\\) is diagonal and can therefore be easily inverted (for pixel-pixel covariance matrix or preconditioning). Each term is related to the number of times a pixel of the map has been observed.\nFor IQU maps, the product is block diagonal, with 3x3 blocks that can also be easily inverted.\nBy adding a rule for this operation, we’ve seen an performance improvement by more than a factor of 10 in the forward application (WIP, currently only for \\(N\\) scalar)."
  },
  {
    "objectID": "iap2024/index.html#furax-algebraic-reductions-composition-of-rotation-matrices",
    "href": "iap2024/index.html#furax-algebraic-reductions-composition-of-rotation-matrices",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX Algebraic Reductions: Composition of Rotation Matrices",
    "text": "FURAX Algebraic Reductions: Composition of Rotation Matrices\nimport jax\nimport jax.numpy as jnp\n\ndef rot(x, y, theta):\n    rotated_x = x * jnp.cos(theta) - y * jnp.sin(theta)\n    rotated_y = x * jnp.sin(theta) + y * jnp.cos(theta)\n    return rotated_x, rotated_y\n\n@jax.jit\ndef func(x, y, theta1, theta2):\n    x, y = rot(x, y, theta=theta1)\n    return rot(x, y, theta=theta2)\n\n\n\n\nCompiled StableHLO representation"
  },
  {
    "objectID": "iap2024/index.html#furax-algebraic-reductions-composition-of-rotation-matrices-1",
    "href": "iap2024/index.html#furax-algebraic-reductions-composition-of-rotation-matrices-1",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX Algebraic Reductions: Composition of Rotation Matrices",
    "text": "FURAX Algebraic Reductions: Composition of Rotation Matrices\nimport jax\nimport jax.numpy as jnp\n\ndef rot(x, y, theta):\n    rotated_x = x * jnp.cos(theta) - y * jnp.sin(theta)\n    rotated_y = x * jnp.sin(theta) + y * jnp.cos(theta)\n    return rotated_x, rotated_y\n\n@jax.jit\ndef func(x, y, theta1, theta2):\n    return rot(x, y, theta=theta1 + theta2)\n\n\n\n\nCompiled StableHLO representation"
  },
  {
    "objectID": "iap2024/index.html#furax-algebraic-reductions-instrument-acquisition",
    "href": "iap2024/index.html#furax-algebraic-reductions-instrument-acquisition",
    "title": "FURAX: a modular JAX toolbox for solving inverse problems in science",
    "section": "FURAX Algebraic Reductions: Instrument Acquisition",
    "text": "FURAX Algebraic Reductions: Instrument Acquisition\nGiven this modeling of the acquisition, using an ideal linear polarizer and an ideal half wave plate: \\[\nH = C_{\\textrm{LP}} \\, R_{2\\theta} \\, R_{-2\\phi} \\, C_{\\textrm{HWP}} \\, R_{2\\phi} \\, R_{2\\psi} \\, P\n\\] with\n\n\\(\\theta\\): detector angle\n\\(\\phi\\): HWP rotation angle\n\\(\\psi\\): telescope rotation angle\n\nFURAX reduces this expression to:\n\\[\nH = C_{\\textrm{LP}} \\, R_{-2\\theta + 4\\phi + 2\\psi}\\, P\n\\]"
  }
]